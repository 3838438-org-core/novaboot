#!/usr/bin/perl -w

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;
use warnings (exists $ENV{NOVABOOT_TEST} ? (FATAL => 'all') : ());
use Getopt::Long qw(GetOptionsFromString GetOptionsFromArray);
use Pod::Usage;
use File::Basename;
use File::Spec;
use IO::Handle;
use Time::HiRes("usleep");
use Socket;
use FileHandle;
use IPC::Open2;
use POSIX qw(:errno_h);
use Cwd qw(getcwd abs_path);
use Expect;

# always flush
$| = 1;

my $invocation_dir = $ENV{PWD} || getcwd();

## Configuration file handling

# Default configuration
$CFG::hypervisor = "";
$CFG::hypervisor_params = "serial";
$CFG::genisoimage = "genisoimage";
$CFG::qemu = 'qemu-system-i386 -cpu coreduo -smp 2';
$CFG::default_target = 'qemu';
%CFG::targets = (
    'qemu' => '--qemu',
    "tud" => '--server=erwin.inf.tu-dresden.de:~sojka/boot/novaboot --rsync-flags="--chmod=Dg+s,ug+w,o-w,+rX --rsync-path=\"umask 002 && rsync\"" --grub --grub-prefix=(nd)/tftpboot/sojka/novaboot --grub-preamble="timeout 0" --concat --iprelay=141.76.48.80:2324 --scriptmod=s/\\\\bhostserial\\\\b/hostserialpci/g',
    "novabox" => '--server=rtime.felk.cvut.cz:/srv/tftp/novaboot --rsync-flags="--chmod=Dg+s,ug+w,o-w,+rX --rsync-path=\"umask 002 && rsync\"" --pulsar --iprelay=147.32.86.92:2324',
    "localhost" => '--scriptmod=s/console=tty[A-Z0-9,]+// --server=/boot/novaboot/$NAME --grub2 --grub-prefix=/boot/novaboot/$NAME --grub2-prolog="  set root=\'(hd0,msdos1)\'"',
    "ryu" =>  '--uboot --uboot-init="mw f0000b00 \${psc_cfg}; sleep 1" --uboot-addr kernel=800000 --uboot-addr ramdisk=b00000 --uboot-addr fdt=7f0000',
    "ryuglab" => '--target ryu --server=pc-sojkam.felk.cvut.cz:/srv/tftp --remote-cmd="ssh -tt pc-sojkam.felk.cvut.cz \"sterm -d -s 115200 /dev/ttyUSB0\""',
    "ryulocal" => '--target ryu --dhcp-tftp --serial --reset-cmd="if which dtrrts; then dtrrts $NB_SERIAL 0 1; sleep 0.1; dtrrts $NB_SERIAL 1 1; fi"',
    );
chomp(my $nproc = `nproc`);
$CFG::scons = "scons -j$nproc";
$CFG::make = "make -j$nproc";

my $builddir;

sub read_config($) {
    my ($cfg) = @_;
    {
	package CFG; # Put config data into a separate namespace

	my $rc = do($cfg);

	# Check for errors
	if ($@) {
	    die("ERROR: Failure compiling '$cfg' - $@");
	} elsif (! defined($rc)) {
	    die("ERROR: Failure reading '$cfg' - $!");
	} elsif (! $rc) {
	    die("ERROR: Failure processing '$cfg'");
	}
    }
    $builddir = File::Spec->rel2abs($CFG::builddir, dirname($cfg)) if defined $CFG::builddir;
    print STDERR "novaboot: Read $cfg\n";
}

my @cfgs;
{
    # We don't use $0 here, because it points to the novaboot itself and
    # not to the novaboot script. The problem with this approach is that
    # when a script is run as "novaboot <options> <script>" then $ARGV[0]
    # contains the first option. Hence the -f check.
    my $dir = File::Spec->rel2abs($ARGV[0] && -f $ARGV[0] ? dirname($ARGV[0]) : '', $invocation_dir);
    while ((-d $dir || -l $dir ) && $dir ne "/") {
	push @cfgs, "$dir/.novaboot" if -r "$dir/.novaboot";
	my @dirs = File::Spec->splitdir($dir);
	$dir = File::Spec->catdir(@dirs[0..$#dirs-1]);
    }
    @cfgs = reverse @cfgs;
    $dir = $ENV{'NOVABOOT_CONFIG_DIR'} || '/etc/novaboot.d';
    if (opendir(my $dh, $dir)) {
	my @etccfg = map { "$dir/$_" } grep { /^[-_a-zA-Z0-9]+$/ && -f "$dir/$_" } readdir($dh);
	closedir $dh;
	@etccfg = sort(@etccfg);
	@cfgs = ( @etccfg, @cfgs );
    }
}
my $cfg = $ENV{'NOVABOOT_CONFIG'};
Getopt::Long::Configure(qw/no_ignore_case pass_through/);
GetOptions ("config|c=s" => \$cfg);
read_config($_) foreach $cfg or @cfgs;

## Command line handling

my $explicit_target;
GetOptions ("target|t=s" => \$explicit_target);

my ($amt, @append, $bender, @chainloaders, $concat, $config_name_opt, $dhcp_tftp, $dump_opt, $dump_config, @exiton, $exiton_timeout, @expect_raw, $gen_only, $grub_config, $grub_prefix, $grub_preamble, $grub2_prolog, $grub2_config, $help, $ider, $iprelay, $iso_image, $interactive, $kernel_opt, $make, $man, $no_file_gen, $off_opt, $on_opt, $pulsar, $pulsar_root, $qemu, $qemu_append, $qemu_flags_cmd, $remote_cmd, $remote_expect, $reset, $reset_cmd, $rom_prefix, $rsync_flags, @scriptmod, $scons, $serial, $server, $stty, $tftp, $tftp_port, $uboot, %uboot_addr, @uboot_init);

$rsync_flags = '';
$rom_prefix = 'rom://';
$stty = 'raw -crtscts -onlcr 115200';
$reset = 1;			# Reset target by default

my @expect_seen = ();
sub handle_expect
{
    my ($n, $v) = @_;
    push(@expect_seen, '-re') if $n eq "expect-re";
    push(@expect_seen, $v);
}

sub handle_send
{
    my ($n, $v) = @_;
    unless (@expect_seen) { die("No --expect before --send"); }
    my $ret = ($n eq "sendcont") ? exp_continue : 0;
    unshift(@expect_raw, sub { shift->send(eval("\"$v\"")); $ret; });
    unshift(@expect_raw, @expect_seen);
    @expect_seen = ();
}

my %opt_spec;
%opt_spec = (
    "amt=s" 	     => \$amt,
    "append|a=s"     => \@append,
    "bender|b"       => \$bender,
    "build-dir=s"    => sub { my ($n, $v) = @_; $builddir = File::Spec->rel2abs($v); },
    "concat"	     => \$concat,
    "chainloader=s"  => \@chainloaders,
    "dhcp-tftp|d"    => \$dhcp_tftp,
    "dump"	     => \$dump_opt,
    "dump-config"    => \$dump_config,
    "exiton=s"       => \@exiton,
    "exiton-timeout=i"=> \$exiton_timeout,
    "exiton-re=s"    => sub { my ($n, $v) = @_; push(@exiton, '-re', $v); },
    "expect=s"	     => \&handle_expect,
    "expect-re=s"    => \&handle_expect,
    "expect-raw=s"   => sub { my ($n, $v) = @_; unshift(@expect_raw, eval($v)); },
    "gen-only"	     => \$gen_only,
    "grub|g:s" 	     => \$grub_config,
    "grub-preamble=s"=> \$grub_preamble,
    "prefix|grub-prefix=s" => \$grub_prefix,
    "grub2:s" 	     => \$grub2_config,
    "grub2-prolog=s" => \$grub2_prolog,
    "ider"           => \$ider,
    "iprelay=s"	     => \$iprelay,
    "iso:s" 	     => \$iso_image,
    "kernel|k=s"     => \$kernel_opt,
    "interactive|i"  => \$interactive,
    "name=s"	     => \$config_name_opt,
    "make|m:s"	     => \$make,
    "no-file-gen"    => \$no_file_gen,
    "off"	     => \$off_opt,
    "on"	     => \$on_opt,
    "pulsar|p:s"     => \$pulsar,
    "pulsar-root=s"  => \$pulsar_root,
    "qemu|Q:s" 	     => \$qemu,
    "qemu-append=s"  => \$qemu_append,
    "qemu-flags|q=s" => \$qemu_flags_cmd,
    "remote-cmd=s"   => \$remote_cmd,
    "remote-expect=s"=> \$remote_expect,
    "reset!"         => \$reset,
    "reset-cmd=s"    => \$reset_cmd,
    "rsync-flags=s"  => \$rsync_flags,
    "scons:s"	     => \$scons,
    "scriptmod=s"    => \@scriptmod,
    "send=s"	     => \&handle_send,
    "sendcont=s"     => \&handle_send,
    "serial|s:s"     => \$serial,
    "server:s" 	     => \$server,
    "strip-rom"	     => sub { $rom_prefix = ''; },
    "stty=s"	     => \$stty,
    "tftp"	     => \$tftp,
    "tftp-port=i"    => \$tftp_port,
    "uboot:s"	     => \$uboot,
    "uboot-addr=s"   => \%uboot_addr,
    "uboot-init=s"   => \@uboot_init,
    "h" 	     => \$help,
    "help" 	     => \$man,
    );

# First process target options
{
    my $t = defined($explicit_target) ? $explicit_target : $CFG::default_target;
    my @target_expanded;
    Getopt::Long::Configure(qw/no_ignore_case pass_through/);
    while ($t) {
	exists $CFG::targets{$t} or die("Unknown target '$t' (valid targets are: ".join(", ", sort keys(%CFG::targets)).")");

	undef $explicit_target;
	my ($ret, $remaining_args) = GetOptionsFromString ($CFG::targets{$t}, ("target|t=s" => \$explicit_target));
	if (!$ret) { die "Error parsing target $t option"; }
	push(@target_expanded, @$remaining_args);
	$t = $explicit_target;
    }
    Getopt::Long::Configure(qw/no_ignore_case no_pass_through/);
    GetOptionsFromArray(\@target_expanded, %opt_spec) or die ("Error in target definition");
}

# Then process other command line options - some of them may override
# what was specified by the target
GetOptions %opt_spec or die("Error in command line arguments");
pod2usage(1) if $help;
pod2usage(-exitstatus => 0, -verbose => 2) if $man;

### Dump sanitized configuration (if requested)

if ($dump_config) {
    use Data::Dumper;
    $Data::Dumper::Indent=1;
    print "# This file is in perl syntax.\n";
    foreach my $key(sort(keys(%CFG::))) { # See "Symbol Tables" in perlmod(1)
	if (defined ${$CFG::{$key}}) { print Data::Dumper->Dump([${$CFG::{$key}}], ["*$key"]); }
	if (        @{$CFG::{$key}}) { print Data::Dumper->Dump([\@{$CFG::{$key}}], ["*$key"]); }
	if (        %{$CFG::{$key}}) { print Data::Dumper->Dump([\%{$CFG::{$key}}], ["*$key"]); }
    }
    print "1;\n";
    exit;
}

### Sanitize configuration

if ($interactive && !-t STDIN) {
    die("novaboot: Interactive mode not supported when not on terminal");
}

if (defined $config_name_opt && scalar(@ARGV) > 1) { die "You cannot use --name with multiple scripts"; }

if ($ider) {
    $iso_image //= ''; # IDE-R needs an ISO image
    if (!defined $amt) { die "Error: --ider requires --amt"; }
}

# Default options
if (defined $serial) {
    $serial ||= "/dev/ttyUSB0";
    $ENV{NB_SERIAL} = $serial;
}
if (defined $grub_config) { $grub_config ||= "menu.lst"; }
if (defined $grub2_config) { $grub2_config ||= "grub.cfg"; }

## Parse the novaboot script(s)
my @scripts;
my $file;
my $EOF;
my $last_fn = '';
my ($modules, $variables, $generated, $continuation) = ([], {}, []);
my $skip_reading = defined($on_opt) || defined($off_opt);
while (!$skip_reading && ($_ = <>)) {
    if ($ARGV ne $last_fn) { # New script
	die "Missing EOF in $last_fn" if $file;
	die "Unfinished line in $last_fn" if $continuation;
	$last_fn = $ARGV;
	push @scripts, { 'filename' => $ARGV,
			 'modules' => $modules = [],
			 'variables' => $variables = {},
			 'generated' => $generated = []};

    }
    chomp();
    next if /^#/ || /^\s*$/;	# Skip comments and empty lines

    $_ =~ s/^[[:space:]]*// if ($continuation);

    if (/\\$/) {		# Line continuation
	$continuation .= substr($_, 0, length($_)-1);
	next;
    }

    if ($continuation) {	# Last continuation line
	$_ = $continuation . $_;
	$continuation = '';
    }

    foreach my $mod(@scriptmod) { eval $mod; }

    if ($file && $_ eq $EOF) {	# Heredoc end
	undef $file;
	next;
    }
    if ($file) {		# Heredoc content
	push @{$file}, "$_\n";
	next;
    }
    if (/^([A-Z_]+)=(.*)$/) {	# Internal variable
	$$variables{$1} = $2;
	push(@exiton, $2) if ($1 eq "EXITON");
	next;
    }
    if (s/^load *//) {		# Load line
	die("novaboot: '$last_fn' line $.: Missing file name\n") unless /^[^ <]+/;
	if (/^([^ ]*)(.*?)[[:space:]]*<<([^ ]*)$/) { # Heredoc start
	    push @$modules, "$1$2";
	    $file = [];
	    push @$generated, {filename => $1, content => $file};
	    $EOF = $3;
	    next;
	}
	if (/^([^ ]*)(.*?)[[:space:]]*< ?(.*)$/) { # Command substitution
	    push @$modules, "$1$2";
	    push @$generated, {filename => $1, command => $3};
	    next;
	}
	push @$modules, $_;
	next;
    }
    if (/^run (.*)/) {		# run line
	push @$generated, {command => $1};
	next;
    }
    if (/^uboot(?::([0-9]+)s)? (.*)/) {	# uboot line
	# TODO: If U-Boot supports some interactive menu, it might
	# make sense to store uboot lines per novaboot script.
	if ($1) {		# Command with explicit timeout
	    push @uboot_init, { command => $2,
				timeout => $1 };
	} else {		# Command without explicit timeout
	    push @uboot_init, $2;
	}
	next;
    }

    die("novaboot: Cannot parse script '$last_fn' line $.. Didn't you forget 'load' keyword?\n");
}
# use Data::Dumper;
# print Dumper(\@scripts);

foreach my $script (@scripts) {
    $modules = $$script{modules};
    @$modules[0] =~ s/^[^ ]*/$kernel_opt/ if $kernel_opt;
    @$modules[0] .= ' ' . join(' ', @append) if @append;

    my $kernel;
    if (exists $variables->{KERNEL}) {
	$kernel = $variables->{KERNEL};
    } else {
	if ($CFG::hypervisor) {
	    $kernel = $CFG::hypervisor . " ";
	    if (exists $variables->{HYPERVISOR_PARAMS}) {
		$kernel .= $variables->{HYPERVISOR_PARAMS};
	    } else {
		$kernel .= $CFG::hypervisor_params;
	    }
	}
    }
    @$modules = ($kernel, @$modules) if $kernel;
    @$modules = (@chainloaders, @$modules);
    @$modules = ("bin/boot/bender", @$modules) if ($bender || defined $ENV{'NOVABOOT_BENDER'});
}

if ($dump_opt) {
    foreach my $script (@scripts) {
	print join("\n", @{$$script{modules}})."\n";
    }
    exit(0);
}

## Helper functions

sub generate_configs($$$) {
    my ($base, $generated, $filename) = @_;
    if ($base) { $base = "$base/"; };
    foreach my $g(@$generated) {
      if (exists $$g{content}) {
	my $config = $$g{content};
	my $fn = $$g{filename};
	open(my $f, '>', $fn) || die("$fn: $!");
	map { s|\brom://([^ ]*)|$rom_prefix$base$1|g; print $f "$_"; } @{$config};
	close($f);
	print "novaboot: Created $fn\n";
      } elsif (exists $$g{command} && ! $no_file_gen) {
	$ENV{SRCDIR} = dirname(File::Spec->rel2abs( $filename, $invocation_dir ));
	if (exists $$g{filename}) {
	    system_verbose("( $$g{command} ) > $$g{filename}");
	} else {
	    system_verbose($$g{command});
	}
      }
    }
}

sub generate_grub_config($$$$;$)
{
    my ($filename, $title, $base, $modules_ref, $preamble) = @_;
    if ($base) { $base = "$base/"; };
    open(my $fg, '>', $filename) or die "$filename: $!";
    print $fg "$preamble\n" if $preamble;
    print $fg "title $title\n" if $title;
    #print $fg "root $base\n"; # root doesn't really work for (nd)
    my $first = 1;
    foreach (@$modules_ref) {
	if ($first) {
	    $first = 0;
	    my ($kbin, $kcmd) = split(' ', $_, 2);
	    $kcmd = '' if !defined $kcmd;
	    print $fg "kernel ${base}$kbin $kcmd\n";
	} else {
	    s|\brom://([^ ]*)|$rom_prefix$base$1|g; # Translate rom:// files - needed for vdisk parameter of sigma0
	    print $fg "module $base$_\n";
	}
    }
    close($fg);
    print("novaboot: Created $builddir/$filename\n");
    return $filename;
}

sub generate_syslinux_config($$$$)
{
    my ($filename, $title, $base, $modules_ref) = @_;
    if ($base && $base !~ /\/$/) { $base = "$base/"; };
    open(my $fg, '>', $filename) or die "$filename: $!";
    print $fg "LABEL $title\n";
    #TODO print $fg "MENU LABEL $human_readable_title\n";

    my ($kbin, $kcmd) = split(' ', @$modules_ref[0], 2);

    if (system("file $kbin|grep 'Linux kernel'") == 0) {
	my $initrd = @$modules_ref[1];
	die('To many "load" lines for Linux kernel') if (scalar @$modules_ref > 2);
	print $fg "LINUX $base$kbin\n";
	print $fg "APPEND $kcmd\n";
	print $fg "INITRD $base$initrd\n";
    } else {
	print $fg "KERNEL mboot.c32\n";
	my @append;
	foreach (@$modules_ref) {
	    s|\brom://([^ ]*)|$rom_prefix$base$1|g; # Translate rom:// files - needed for vdisk parameter of sigma0
	    push @append, "$base$_";
	    print $fg "APPEND ".join(' --- ', @append)."\n";
	}
    }
    #TODO print $fg "TEXT HELP\n";
    #TODO print $fg "some help here\n";
    #TODO print $fg "ENDTEXT\n";
    close($fg);
    print("novaboot: Created $builddir/$filename\n");
    return $filename;
}

sub generate_grub2_config($$$$;$$)
{
    my ($filename, $title, $base, $modules_ref, $preamble, $prolog) = @_;
    if ($base && substr($base,-1,1) ne '/') { $base = "$base/"; };
    open(my $fg, '>', $filename) or die "$filename: $!";
    print $fg "$preamble\n" if $preamble;
    $title ||= 'novaboot';
    print $fg "menuentry $title {\n";
    print $fg "$prolog\n" if $prolog;
    my $first = 1;
    foreach (@$modules_ref) {
	if ($first) {
	    $first = 0;
	    my ($kbin, $kcmd) = split(' ', $_, 2);
	    $kcmd = '' if !defined $kcmd;
	    print $fg "  multiboot ${base}$kbin $kcmd\n";
	} else {
	    my @args = split;
	    # GRUB2 doesn't pass filename in multiboot info so we have to duplicate it here
	    $_ = join(' ', ($args[0], @args));
	    s|\brom://|$rom_prefix|g; # We do not need to translate path for GRUB2
	    print $fg "  module $base$_\n";
	}
    }
    print $fg "}\n";
    close($fg);
    print("novaboot: Created $builddir/$filename\n");
    return $filename;
}

sub generate_pulsar_config($$)
{
    my ($filename, $modules_ref) = @_;
    open(my $fg, '>', $filename) or die "$filename: $!";
    print $fg "root $pulsar_root\n" if defined $pulsar_root;
    my $first = 1;
    my ($kbin, $kcmd);
    foreach (@$modules_ref) {
	if ($first) {
	    $first = 0;
	    ($kbin, $kcmd) = split(' ', $_, 2);
	    $kcmd = '' if !defined $kcmd;
	} else {
	    my @args = split;
	    s|\brom://|$rom_prefix|g;
	    print $fg "load $_\n";
	}
    }
    # Put kernel as last - this is needed for booting Linux and has no influence on non-Linux OSes
    print $fg "exec $kbin $kcmd\n";
    close($fg);
    print("novaboot: Created $builddir/$filename\n");
    return $filename;
}

sub shell_cmd_string(@)
{
    return join(' ', map((/^[-_=a-zA-Z0-9\/\.\+]+$/ ? "$_" : "'$_'"), @_));
}

sub exec_verbose(@)
{
    print "novaboot: Running: ".shell_cmd_string(@_)."\n";
    exec(@_);
    exit(1); # should not be reached
}

sub system_verbose($)
{
    my $cmd = shift;
    print "novaboot: Running: $cmd\n";
    my $ret = system($cmd);
    if ($ret & 0x007f) { die("Command terminated by a signal"); }
    if ($ret & 0xff00) {die("Command exit with non-zero exit code"); }
    if ($ret) { die("Command failure $ret"); }
}

## WvTest headline

if (exists $variables->{WVDESC}) {
    print "Testing \"$variables->{WVDESC}\" in $last_fn:\n";
} elsif ($last_fn =~ /\.wv$/) {
    print "Testing \"all\" in $last_fn:\n";
}

## Connect to the target and check whether it is not occupied

# We have to do this before file generation phase, because file
# generation is intermixed with file deployment phase and we want to
# check whether the target is not used by somebody else before
# deploying files. Otherwise, we may rewrite other user's files on a
# boot server.

my $exp; # Expect object to communicate with the target over serial line

my ($target_reset, $target_power_on, $target_power_off);
my ($amt_user, $amt_password, $amt_host, $amt_port);

if (defined $iprelay) {
    my $IPRELAY;
    $iprelay =~ /([.0-9]+)(:([0-9]+))?/;
    my $addr = $1;
    my $port = $3 || 23;
    my $paddr   = sockaddr_in($port, inet_aton($addr));
    my $proto   = getprotobyname('tcp');
    socket($IPRELAY, PF_INET, SOCK_STREAM, $proto)  || die "socket: $!";
    print "novaboot: Connecting to IP relay... ";
    connect($IPRELAY, $paddr)    || die "connect: $!";
    print "done\n";
    $exp = Expect->init(\*$IPRELAY);
    $exp->log_stdout(1);

    while (1) {
	print $exp "\xFF\xF6";	# AYT
	my $connected = $exp->expect(20, # Timeout in seconds
				     '<iprelayd: connected>',
				     '-re', '<WEB51 HW[^>]*>');
	last if $connected;
    }

    sub relaycmd($$) {
	my ($relay, $onoff) = @_;
	die unless ($relay == 1 || $relay == 2);

	my $cmd = ($relay == 1 ? 0x5 : 0x6) | ($onoff ? 0x20 : 0x10);
	return "\xFF\xFA\x2C\x32".chr($cmd)."\xFF\xF0";
    }

    sub relayconf($$) {
	my ($relay, $onoff) = @_;
	die unless ($relay == 1 || $relay == 2);
	my $cmd = ($relay == 1 ? 0xdf : 0xbf) | ($onoff ? 0x00 : 0xff);
	return "\xFF\xFA\x2C\x97".chr($cmd)."\xFF\xF0";
    }

    sub relay($$;$) {
	my ($relay, $onoff, $can_giveup) = @_;
	my $confirmation = '';
	$exp->log_stdout(0);
	print $exp relaycmd($relay, $onoff);
	my $confirmed = $exp->expect(20, # Timeout in seconds
				     relayconf($relay, $onoff));
	if (!$confirmed) {
	    if ($can_giveup) {
		print("Relay confirmation timeout - ignoring\n");
	    } else {
		die "Relay confirmation timeout";
	    }
	}
	$exp->log_stdout(1);
    }

    $target_reset = sub {
	relay(2, 1, 1); # Reset the machine
	usleep(100000);
	relay(2, 0);
    };

    $target_power_off = sub {
	relay(1, 1);		# Press power button
	usleep(6000000);	# Long press to switch off
	relay(1, 0);
    };

    $target_power_on = sub {
	relay(1, 1);		# Press power button
	usleep(100000);		# Short press
	relay(1, 0);
    };
}
elsif ($serial) {
    my $CONN;
    system_verbose("stty -F $serial $stty");
    open($CONN, "+<", $serial) || die "open $serial: $!";
    $exp = Expect->init(\*$CONN);
}
elsif ($remote_cmd) {
    print "novaboot: Running: $remote_cmd\n";
    $exp = Expect->spawn($remote_cmd);
}
elsif (defined $amt) {
    require LWP::UserAgent;
    require LWP::Authen::Digest;

    sub genXML {
        my ($host, $username, $password, $schema, $className, $pstate) = @_;
	#AMT numbers for PowerStateChange (MNI => bluescreen on windows;-)
	my %pstates = ("on"	   => 2,
		       "standby"   => 4,
		       "hibernate" => 7,
		       "off"	   => 8,
		       "reset"	   => 10,
		       "MNI"	   => 11);
        return <<END;
		<s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:w="http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd">
		<s:Header><a:To>http://$host:16992/wsman</a:To>
		<w:ResourceURI s:mustUnderstand="true">$schema</w:ResourceURI>
		<a:ReplyTo><a:Address s:mustUnderstand="true">http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</a:Address></a:ReplyTo>
		<a:Action s:mustUnderstand="true">$schema$className</a:Action>
		<w:MaxEnvelopeSize s:mustUnderstand="true">153600</w:MaxEnvelopeSize>
		<a:MessageID>uuid:709072C9-609C-4B43-B301-075004043C7C</a:MessageID>
		<w:Locale xml:lang="en-US" s:mustUnderstand="false" />
		<w:OperationTimeout>PT60.000S</w:OperationTimeout>
		<w:SelectorSet><w:Selector Name="Name">Intel(r) AMT Power Management Service</w:Selector></w:SelectorSet>
		</s:Header><s:Body>
		<p:RequestPowerStateChange_INPUT xmlns:p="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_PowerManagementService">
		<p:PowerState>$pstates{$pstate}</p:PowerState>
		<p:ManagedElement><a:Address>http://$host:16992/wsman</a:Address>
		<a:ReferenceParameters><w:ResourceURI>http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ComputerSystem</w:ResourceURI>
		<w:SelectorSet><w:Selector Name="Name">ManagedSystem</w:Selector></w:SelectorSet>
		</a:ReferenceParameters></p:ManagedElement>
		</p:RequestPowerStateChange_INPUT>
		</s:Body></s:Envelope>
END
    }

    sub sendPOST {
        my ($host, $username, $password, $content) = @_;

        my $ua = LWP::UserAgent->new();
        $ua->agent("novaboot");

	my $req = HTTP::Request->new(POST => "http://$host:16992/wsman");
        my $res = $ua->request($req);
        die ("Unexpected AMT response: " . $res->status_line) unless $res->code == 401;

        my ($realm) = $res->header("WWW-Authenticate") =~ /Digest realm="(.*?)"/;
        $ua->credentials("$host:16992", $realm, $username => $password);

        # Create a request
        $req = HTTP::Request->new(POST => "http://$host:16992/wsman");
        $req->content_type('application/x-www-form-urlencoded');
        $req->content($content);
        $res = $ua->request($req);
        die ("AMT power change request failed: " . $res->status_line) unless $res->is_success;
        $res->content() =~ /<g:ReturnValue>(\d+)<\/g:ReturnValue>/;
        return $1;
    }

    sub powerChange  {
        my ($host, $username, $password, $pstate)=@_;
        my $schema="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_PowerManagementService";
        my $className="/RequestPowerStateChange";
        my $content = genXML($host, $username, $password ,$schema, $className, $pstate);
        return sendPOST($host, $username, $password, $content);
    }

    ($amt_user,$amt_password,$amt_host,$amt_port) = ($amt =~ /(?:(.*?)(?::(.*))?@)?([^:]*)(?::([0-9]*))?/);;
    $amt_user ||= "admin";
    $amt_password ||= $ENV{'AMT_PASSWORD'} || die "AMT password not specified";
    $amt_host || die "AMT host not specified";
    $amt_port ||= 16994;


    $target_power_off = sub {
	$exp->close();
	my $result = powerChange($amt_host,$amt_user,$amt_password, "off");
	die "AMT power off failed (ReturnValue $result)" if $result != 0;
    };

    $target_power_on = sub {
	my $result = powerChange($amt_host,$amt_user,$amt_password, "on");
	die "AMT power on failed (ReturnValue $result)" if $result != 0;
    };

    $target_reset = sub {
	my $result = powerChange($amt_host,$amt_user,$amt_password, "reset");
	if ($result != 0) {
	    print STDERR "Warning: Cannot reset $amt_host, trying power on. ";
	    $result = powerChange($amt_host,$amt_user,$amt_password, "on");
	}
	die "AMT reset failed (ReturnValue $result)" if $result != 0;
    };

    my $cmd = "amtterm -u $amt_user -p $amt_password $amt_host $amt_port";
    print "novaboot: Running: $cmd\n" =~ s/\Q$amt_password\E/???/r;
    $exp = Expect->spawn($cmd);
    $exp->expect(10, "RUN_SOL") || die "Expect for 'RUN_SOL' timed out";

}


if ($remote_expect) {
    $exp || die("No serial line connection");
    $exp->expect(180, $remote_expect) || die "Expect for '$remote_expect' timed out";
}

if (defined $reset_cmd) {
    $target_reset = sub {
	system_verbose($reset_cmd);
    };
}

if (defined $on_opt && defined $target_power_on) {
    &$target_power_on();
    exit;
}
if (defined $off_opt && defined $target_power_off) {
    print "novaboot: Switching the target off...\n";
    &$target_power_off();
    exit;
}

$builddir ||= dirname(File::Spec->rel2abs( ${$scripts[0]}{filename})) if scalar @scripts;
if (defined $builddir) {
    chdir($builddir) or die "Can't change directory to $builddir: $!";
    print "novaboot: Entering directory `$builddir'\n";
} else {
    $builddir = $invocation_dir;
}

## File generation phase
my (%files_iso, $menu_iso, $filename);
my $config_name = '';
my $prefix = '';

foreach my $script (@scripts) {
    $filename = $$script{filename};
    $modules = $$script{modules};
    $generated = $$script{generated};
    $variables = $$script{variables};

    ($config_name = $filename) =~ s#.*/##;
    $config_name = $config_name_opt if (defined $config_name_opt);

    if (exists $variables->{BUILDDIR}) {
	$builddir = File::Spec->rel2abs($variables->{BUILDDIR});
	chdir($builddir) or die "Can't change directory to $builddir: $!";
	print "novaboot: Entering directory `$builddir'\n";
    }

    if ($grub_prefix) {
	$prefix = $grub_prefix;
	$prefix =~ s/\$NAME/$config_name/;
	$prefix =~ s/\$BUILDDIR/$builddir/;
    }
    # TODO: use $grub_prefix as first parameter if some switch is given
    generate_configs('', $generated, $filename);

### Generate bootloader configuration files
    my @bootloader_configs;
    push @bootloader_configs, generate_grub_config($grub_config, $config_name, $prefix, $modules, $grub_preamble) if (defined $grub_config);
    push @bootloader_configs, generate_grub2_config($grub2_config, $config_name, $prefix, $modules, $grub_preamble, $grub2_prolog) if (defined $grub2_config);
    push @bootloader_configs, generate_pulsar_config('config-'.($pulsar||'novaboot'), $modules) if (defined $pulsar);

### Run scons or make
    {
	my @files = map({ ($file) = m/([^ ]*)/; $file; } @$modules);
	# Filter-out generated files
	my @to_build = grep({ my $file = $_; !scalar(grep($file eq ($$_{filename} || ''), @$generated)) } @files);

	system_verbose($scons || $CFG::scons." ".join(" ", @to_build)) if (defined $scons);
	system_verbose($make  || $CFG::make ." ".join(" ", @to_build)) if (defined $make);
    }

### Copy files (using rsync)
    if (defined $server && !defined($gen_only)) {
	(my $real_server = $server) =~ s/\$NAME/$config_name/;

	my ($hostname, $path) = split(":", $real_server, 2);
	if (! defined $path) {
	    $path = $hostname;
	    $hostname = "";
	}
	my $files = join(" ", map({ ($file) = m/([^ ]*)/; $file; } ( @$modules, @bootloader_configs)));
	map({ my $file = (split)[0]; die "$file: $!" if ! -f $file; } @$modules);
	my $istty = -t STDOUT && ($ENV{'TERM'} || 'dumb') ne 'dumb';
	my $progress = $istty ? "--progress" : "";
	system_verbose("rsync $progress -RLp $rsync_flags $files $real_server");
	if ($server =~ m|/\$NAME$| && $concat) {
	    my $cmd = join("; ", map { "( cd $path/.. && cat */$_ > $_ )" } @bootloader_configs);
	    system_verbose($hostname ? "ssh $hostname '$cmd'" : $cmd);
	}
    }

### Prepare ISO image generation
    if (defined $iso_image) {
	generate_configs("(cd)", $generated, $filename);
	my $menu;
	generate_syslinux_config(\$menu, $config_name, "/", $modules);
	$menu_iso .= "$menu\n";
	map { ($file,undef) = split; $files_iso{$file} = 1; } @$modules;
    }
}

## Generate ISO image
if (defined $iso_image) {
    system_verbose("mkdir -p isolinux");

    my @files;
    if (-f '/usr/lib/ISOLINUX/isolinux.bin') {
	# Newer ISOLINUX version
	@files = qw(/usr/lib/ISOLINUX/isolinux.bin /usr/lib/syslinux/modules/bios/mboot.c32 /usr/lib/syslinux/modules/bios/libcom32.c32 /usr/lib/syslinux/modules/bios/menu.c32 /usr/lib/syslinux/modules/bios/ldlinux.c32);
    } else {
	# Older ISOLINUX version
	@files = qw(/usr/lib/syslinux/isolinux.bin /usr/lib/syslinux/mboot.c32 /usr/lib/syslinux/menu.c32);
    }
    system_verbose("cp @files isolinux");
    open(my $fh, ">isolinux/isolinux.cfg");
    if ($#scripts) {
	print $fh "TIMEOUT 50\n";
	print $fh "DEFAULT menu\n";
    } else {
	print $fh "DEFAULT $config_name\n";
    }
    print $fh "$menu_iso";
    close($fh);

    my $files = join(" ", map("$_=$_", (keys(%files_iso), 'isolinux/isolinux.cfg', map(s|.*/|isolinux/|r, @files))));
    $iso_image ||= "$config_name.iso";

    # Note: We use -U flag below to "Allow 'untranslated' filenames,
    # completely violating the ISO9660 standards". Without this
    # option, isolinux is not able to read files names for example
    # bzImage-3.0.
    system_verbose("$CFG::genisoimage -R -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -hide-rr-moved -U -o $iso_image -graft-points $files");
    print("ISO image created: $builddir/$iso_image\n");
}

exit(0) if defined $gen_only;

## Boot the system using various methods and send serial output to stdout

if (scalar(@scripts) > 1 && ( defined $dhcp_tftp || defined $serial || defined $iprelay)) {
    die "You cannot do this with multiple scripts simultaneously";
}

if ($variables->{WVTEST_TIMEOUT}) {
    print "wvtest: timeout ", $variables->{WVTEST_TIMEOUT}, "\n";
}

sub trim($) {
    my ($str) = @_;
    $str =~ s/^\s+|\s+$//g;
    return $str
}

### Start in Qemu

if (defined $qemu) {
    # Qemu
    $qemu ||= $variables->{QEMU} || $CFG::qemu;
    my @qemu_flags = split(" ", $qemu);
    $qemu = shift(@qemu_flags);

    @qemu_flags = split(/ +/, trim($variables->{QEMU_FLAGS})) if exists $variables->{QEMU_FLAGS};
    @qemu_flags = split(/ +/, trim($qemu_flags_cmd)) if $qemu_flags_cmd;
    push(@qemu_flags, split(/ +/, trim($qemu_append || '')));

    if (defined $iso_image) {
	# Boot NOVA with grub (and test the iso image)
	push(@qemu_flags, ('-cdrom', $iso_image));
    } else {
	# Boot NOVA without GRUB

	# Non-patched qemu doesn't like commas, but NUL can live with pluses instead of commans
	foreach (@$modules) {s/,/+/g;}
	generate_configs("", $generated, $filename);

	if (scalar @$modules) {
	    my ($kbin, $kcmd) = split(' ', shift(@$modules), 2);
	    $kcmd = '' if !defined $kcmd;
	    my $dtb;
	    @$modules = map { if (/\.dtb$/) { $dtb=$_; (); } else { $_ } } @$modules;
	    my $initrd = join ",", @$modules;

	    push(@qemu_flags, ('-kernel', $kbin, '-append', $kcmd));
	    push(@qemu_flags, ('-initrd', $initrd)) if $initrd;
	    push(@qemu_flags, ('-dtb', $dtb)) if $dtb;
	}
    }
    push(@qemu_flags,  qw(-serial stdio)); # Redirect serial output (for collecting test restuls)
    unshift(@qemu_flags, ('-name', $config_name));
    print "novaboot: Running: ".shell_cmd_string($qemu, @qemu_flags)."\n";
    $exp = Expect->spawn(($qemu, @qemu_flags)) || die("exec() failed: $!");
}

### Local DHCPD and TFTPD

my ($dhcpd_pid, $tftpd_pid);

$tftp=1 if $tftp_port;

if (defined $dhcp_tftp)
{
    generate_configs("(nd)", $generated, $filename);
    system_verbose('mkdir -p tftpboot');
    generate_grub_config("tftpboot/os-menu.lst", $config_name, "(nd)", \@$modules, "timeout 0");
    open(my $fh, '>', 'dhcpd.conf');
    my $mac = `cat /sys/class/net/eth0/address`;
    chomp $mac;
    print $fh "subnet 10.23.23.0 netmask 255.255.255.0 {
		      range 10.23.23.10 10.23.23.100;
		      filename \"bin/boot/grub/pxegrub.pxe\";
		      next-server 10.23.23.1;
}
host server {
	hardware ethernet $mac;
	fixed-address 10.23.23.1;
}";
    close($fh);
    system_verbose("sudo ip a add 10.23.23.1/24 dev eth0;
	    sudo ip l set dev eth0 up;
	    sudo touch dhcpd.leases");

    # We run servers by forking ourselves, because the servers end up
    # in our process group and get killed by signals sent to the
    # process group (e.g. Ctrl-C on terminal).
    $dhcpd_pid = fork();
    exec_verbose("sudo dhcpd -d -cf dhcpd.conf -lf dhcpd.leases -pf dhcpd.pid") if ($dhcpd_pid == 0);
}

if (defined $dhcp_tftp || defined $tftp) {
    $tftp_port ||= 69;
    # Unfortunately, tftpd requires root privileges even with
    # non-privileged (>1023) port due to initgroups().
    system_verbose("sudo in.tftpd --listen --secure -v -v -v --pidfile tftpd.pid  --address :$tftp_port $builddir");

    # Kill server when we die
    $SIG{__DIE__} = sub { system_verbose('sudo pkill --pidfile=dhcpd.pid') if (defined $dhcp_tftp);
			  system_verbose('sudo pkill --pidfile=tftpd.pid'); };

    # We have to kill tftpd explicitely, because it is not in our process group
    $SIG{INT} = sub { system_verbose('sudo pkill --pidfile=tftpd.pid'); exit(0); };
}

### AMT IDE-R
if (defined $ider) {
    my $ider_cmd= "amtider -c $iso_image -u $amt_user -p $amt_password $amt_host $amt_port"  ;
    print "novaboot: Running: $ider_cmd\n" =~ s/\Q$amt_password\E/???/r;
    my $ider_pid = fork();
    if ($ider_pid == 0) {
	exec($ider_cmd);
	die "IDE redirection failed";
    }
    # FIXME: This collides with --tftp option. Hopefully, nobody needs
    # to use both simultaneously.
    $SIG{__DIE__} = sub { system_verbose('kill $ider_pid'); };
}

### Reset target (IP relay, AMT, ...)

if (defined $target_reset && $reset) {
    print "novaboot: Reseting the test box... ";
    &$target_reset();
    print "done\n";
}

### U-boot conversation
if (defined $uboot) {
    my $uboot_prompt = $uboot || '=> ';
    print "novaboot: Waiting for U-Boot prompt...\n";
    $exp || die("No serial line connection");
    $exp->log_stdout(1);
    #$exp->exp_internal(1);
    $exp->expect(20,
		 [qr/Hit any key to stop autoboot:/, sub { $exp->send("\n"); exp_continue; }],
		 $uboot_prompt) || die "No U-Boot prompt deteceted";
    foreach my $cmdspec (@uboot_init) {
	my ($cmd, $timeout);
	if (ref($cmdspec) eq "HASH") {
	    $cmd = $cmdspec->{command};
	    $timeout = $cmdspec->{timeout};
	} else {
	    $cmd = $cmdspec;
	    $timeout = 10;
	}
	if ($cmd =~ /\$NB_MYIP/) {
	    my $ip = (grep /inet /, `ip addr show eth0`)[0] || die "Problem determining our IP address";
	    $ip =~ s/\s*inet ([0-9.]*).*/$1/;
	    $cmd =~ s/\$NB_MYIP/$ip/g;
	}
	if ($cmd =~ /\$NB_PREFIX/) {
	    my $p = $prefix;
	    $p =~ s|/*$||;
	    $cmd =~ s/\$NB_PREFIX/$p/g;
	}
	chomp($cmd);
	$exp->send("$cmd\n");
	$exp->expect($timeout, $uboot_prompt) || die "U-Boot prompt timeout";
    }

    # Boot the system if there are some load lines in the script
    if (scalar(@$modules) > 0 && !$variables->{NO_BOOT}) {
	my ($kbin, $kcmd) = split(' ', shift(@$modules), 2);
	my $dtb;
	@$modules = map { if (/\.dtb$/) { $dtb=$_; (); } else { $_ } } @$modules;
	my $initrd = shift @$modules;

	my ($ramdisk_addr, $fdt_addr) = ('-', '');

	die "No '--uboot-addr kernel' given" unless $uboot_addr{kernel};
	$exp->send("tftpboot $uboot_addr{kernel} $prefix$kbin\n");
	$exp->expect(10,
		     [qr/##/, sub { exp_continue; }],
		     $uboot_prompt) || die "Kernel load timeout";
	if (defined $dtb) {
	    die "No '--uboot-addr fdt' given" unless $uboot_addr{fdt};
	    $fdt_addr = $uboot_addr{fdt};
	    $exp->send("tftpboot $fdt_addr $prefix$dtb\n");
	    $exp->expect(10,
			 [qr/##/, sub { exp_continue; }],
			 $uboot_prompt) || die "Device tree load timeout";
	}
	if (defined $initrd) {
	    die "No '--uboot-addr ramdisk' given" unless $uboot_addr{ramdisk};
	    $ramdisk_addr = $uboot_addr{ramdisk};
	    $exp->send("tftpboot $ramdisk_addr $prefix$initrd\n");
	    $exp->expect(10,
			 [qr/#/, sub { exp_continue; }],
			 $uboot_prompt) || die "Initrd load timeout";
	}
	$exp->send("echo $kcmd\n");
	$exp->expect(1, '-re', qr{echo .*\n(.*)\n$uboot_prompt})  || die "Command line test timeout";
	my $args = ($exp->matchlist)[0];
	if ($args =~ /^setenv\s+bootargs/) {
	    $exp->send("$args\n");
	} else {
	    $exp->send("setenv bootargs $kcmd\n");
	}
	$exp->expect(5, $uboot_prompt)  || die "U-Boot prompt timeout";
	$exp->send("bootm $uboot_addr{kernel} $ramdisk_addr $fdt_addr\n");
	$exp->expect(5, "\n")  || die "U-Boot command timeout";
    }
}

### Serial line interaction
if (defined $exp) {
    # Serial line of the target is available
    my $interrupt = 'Ctrl-C';
    if ($interactive && !@exiton) {
	$interrupt = '"~~."';
    }
    my $note = (-t STDIN) ? '' : '- only target->host ';
    print "novaboot: Serial line interaction $note(press $interrupt to interrupt)...\n";
    $exp->log_stdout(1);
    if (@exiton) {
	$exp->expect($exiton_timeout, @expect_raw, @exiton) || die("exiton timeout");
    } else {
	my @inputs = ($exp);
	if (-t STDIN) { # Set up bi-directional communication if we run on terminal
	    my $infile = new IO::File;
	    $infile->IO::File::fdopen(*STDIN,'r');
	    my $in_object = Expect->exp_init($infile);
	    $in_object->set_group($exp);

	    if ($interactive) {
		$in_object->set_seq('~~\.', sub { print "novaboot: Escape sequence detected\r\n"; undef; });
		$in_object->manual_stty(0);	  # Use raw terminal mode
	    } else {
		$in_object->manual_stty(1);	  # Do not modify terminal settings
	    }
	    push(@inputs, $in_object);
	}
	#use Data::Dumper;
	#print Dumper(\@expect_raw);
	$exp->expect(undef, @expect_raw) if @expect_raw;
	Expect::interconnect(@inputs) unless defined($exp->exitstatus);
    }
}

## Kill dhcpc or tftpd
if (defined $dhcp_tftp || defined $tftp) {
    die("novaboot: This should kill servers on background\n");
}

## Documentation

=head1 NAME

novaboot - Boots a locally compiled operating system on a remote
target or in qemu

=head1 SYNOPSIS

B<novaboot> --help

B<novaboot> [option]... [--] script...

B<./script> [option]...

=head1 DESCRIPTION

This program makes booting of a locally compiled operating system (OS)
(e.g. NOVA or Linux) on remote targets as simple as running a program
locally. It automates things like copying OS images to a TFTP server,
generation of bootloader configuration files, resetting of target
hardware or redirection of target's serial line to stdin/out. Novaboot
is highly configurable and it makes it easy to boot a single image on
different targets or different images on a single target.

Novaboot operation is controlled by command line options and by a so
called novaboot script, which can be thought as a generalization of
bootloader configuration files (see L</"NOVABOOT SCRIPT SYNTAX">).
Typical way of using novaboot is to make the novaboot script
executable and set its first line to I<#!/usr/bin/env novaboot>. Then,
booting a particular OS configuration becomes the same as executing a
local program - the novaboot script.

Novaboot uses configuration files to, among other things, define
command line options needed for different targets. Users typically use
only the B<-t>/B<--target> command line option to select the target.
Internally, this option expands to the pre-configured options.
Configuration files are searched at multiple places, which allows to
have per-system, per-user or per-project configurations. Configuration
file syntax is described in section L</"CONFIGURATION FILE">.

Simple examples of using C<novaboot>:

=over 3

=item 1.

Run an OS in Qemu. This is the default action when no other action is
specified by command line switches. Thus running C<novaboot myos> (or
C<./myos> as described above) will run Qemu and make it boot the
configuration specified in the F<myos> script.

=item 2.

Create a bootloader configuration file (currently supported
bootloaders are GRUB, GRUB2, ISOLINUX, Pulsar and U-Boot) and copy it
with all other files needed for booting to a remote boot server. Then
use a TCP/IP-controlled relay/serial-to-TCP converter to reset the
target and receive its serial output.

 ./myos --grub2 --server=192.168.1.1:/tftp --iprelay=192.168.1.2

=item 3.

Run DHCP and TFTP server on developer's machine to boot the target
from it.

 ./myos --dhcp-tftp

This is useful when no network infrastructure is in place and
the target is connected directly to developer's box.

=item 4.

Create bootable ISO image.

 novaboot --iso -- script1 script2

The created ISO image will have ISOLINUX bootloader installed on it
and the boot menu will allow selecting between I<script1> and
I<script2> configurations.

=back

=head1 PHASES AND OPTIONS

Novaboot performs its work in several phases. Each phase can be
influenced by several command line options, certain phases can be
skipped. The list of phases (in the execution order) and the
corresponding options follows.

=head2 Configuration reading phase

After starting, novaboot reads configuration files. Their content is
described in section L</"CONFIGURATION FILE">. By default,
configuration is read from two locations. First from the configuration
directory and second from F<.novaboot> files along the path to the
current directory. The latter read files override settings from the
former ones.

Configuration directory is determined by the content of
NOVABOOT_CONFIG_DIR environment variable and defaults to
F</etc/novaboot.d>. Files in this directory with names consisting
solely of English letters, numbers, dashes '-' and underscores '_'
(note that dot '.' is not included) are read in alphabetical order.

Then novaboot searches for files named F<.novaboot> starting from the
directory of the novaboot script (or working directory, see bellow)
and continuing upwards up to the root directory. The found
configuration files are then read in the opposite order (i.e. from the
root directory downwards). This allows to have, for example, user
specific configuration in F<~/.novaboot> and project specific one in
F<~/project/.novaboot>.

In certain cases, the location of the novaboot script cannot be
determined in this early phase. This happens either when the script is
read from the standard input or when novaboot is invoked explicitly as
in the example L</"4."> above. In this case the current working
directory is used as a starting point for configuration file search
instead of the novaboot script directory.

=over 8

=item -c, --config=I<filename>

Use the specified configuration file instead of the default one(s).

=back

=head2 Command line processing phase

=over 8

=item --dump-config

Dump the current configuration to stdout end exit. Useful as an
initial template for a configuration file.

=item -h, --help

Print short (B<-h>) or long (B<--help>) help.

=item -t, --target=I<target>

This option serves as a user configurable shortcut for other novaboot
options. The effect of this option is the same as the options stored
in the C<%targets> configuration variable under key I<target>. See
also L</"CONFIGURATION FILE">.

=back

=head2 Script preprocessing phase

This phases allows to modify the parsed novaboot script before it is
used in the later phases.

=over 8

=item -a, --append=I<parameters>

Append a string to the first C<load> line in the novaboot script. This
can be used to append parameters to the kernel's or root task's
command line. This option can appear multiple times.

=item -b, --bender

Use F<bender> chainloader. Bender scans the PCI bus for PCI serial
ports and stores the information about them in the BIOS data area for
use by the kernel.

=item --chainloader=I<chainloader>

Specifies a chainloader that is loaded before the kernel and other
files specified in the novaboot script. E.g. 'bin/boot/bender
promisc'.

=item --dump

Print the modules to boot and their parameters after this phase
finishes. Then exit. This is useful for seeing the effect of other
options in this section.

=item -k, --kernel=F<file>

Replace the first word on the first C<load> line in the novaboot
script with F<file>.

=item --scriptmod=I<perl expression>

When novaboot script is read, I<perl expression> is executed for every
line (in $_ variable). For example, C<novaboot
--scriptmod=s/sigma0/omega6/g> replaces every occurrence of I<sigma0>
in the script with I<omega6>.

When this option is present, it overrides I<$script_modifier> variable
from the configuration file, which has the same effect. If this option
is given multiple times all expressions are evaluated in the command
line order.

=back

=head2 File generation phase

In this phase, files needed for booting are generated in a so called
I<build directory> (see L</--build-dir>). In most cases configuration
for a bootloader is generated automatically by novaboot. It is also
possible to generate other files using I<heredoc> or I<"<"> syntax in
novaboot scripts. Finally, binaries can be generated in this phases by
running C<scons> or C<make>.

=over 8

=item --build-dir=I<directory>

Overrides the default build directory location.

The default build directory location is determined as follows: If the
configuration file defines the C<$builddir> variable, its value is
used. Otherwise, it is the directory that contains the first processed
novaboot script.

See also L</BUILDDIR> variable.

=item -g, --grub[=I<filename>]

Generates grub bootloader menu file. If the I<filename> is not
specified, F<menu.lst> is used. The I<filename> is relative to the
build directory (see B<--build-dir>).

=item --grub-preamble=I<prefix>

Specifies the I<preable> that is at the beginning of the generated
GRUB or GRUB2 config files. This is useful for specifying GRUB's
timeout.

=item --prefix=I<prefix>

Specifies I<prefix> (e.g. F</srv/tftp>) that is put in front of every
file name in generated bootloader configuration files (or in U-Boot
commands).

If the I<prefix> contains string $NAME, it will be replaced with the
name of the novaboot script (see also B<--name>).

If the I<prefix> contains string $BUILDDIR, it will be replaced with
the build directory (see also B<--build-dir>).

=item --grub-prefix

Alias for B<--prefix>.

=item --grub2[=I<filename>]

Generate GRUB2 menu entry in I<filename>. If I<filename> is not
specified F<grub.cfg> is used. The content of the menu entry can be
customized with B<--grub-preamble>, B<--grub2-prolog> or
B<--grub_prefix> options.

In order to use the the generated menu entry on your development
machine that uses GRUB2, append the following snippet to
F</etc/grub.d/40_custom> file and regenerate your grub configuration,
i.e. run update-grub on Debian/Ubuntu.

  if [ -f /path/to/nul/build/grub.cfg ]; then
    source /path/to/nul/build/grub.cfg
  fi

=item --grub2-prolog=I<prolog>

Specifies text that is put at the beginning of the GRUB2 menu entry.

=item -m, --make[=make command]

Runs C<make> to build files that are not generated by novaboot itself.

=item --name=I<string>

Use the name I<string> instead of the name of the novaboot script.
This name is used for things like a title of grub menu or for the
server directory where the boot files are copied to.

=item --no-file-gen

Do not run external commands to generate files (i.e. "<" syntax and
C<run> keyword). This switch does not influence generation of files
specified with "<<WORD" syntax.

=item -p, --pulsar[=mac]

Generates pulsar bootloader configuration file named F<config-I<mac>>
The I<mac> string is typically a MAC address and defaults to
I<novaboot>.

=item --scons[=scons command]

Runs C<scons> to build files that are not generated by novaboot
itself.

=item --strip-rom

Strip I<rom://> prefix from command lines and generated config files.
The I<rom://> prefix is used by NUL. For NRE, it has to be stripped.

=item --gen-only

Exit novaboot after file generation phase.

=back

=head2 Target connection check

If supported by the target, the connection to it is made and it is
checked whether the target is not occupied by another novaboot
user/instance.

=over 8

=item --amt=I<"[user[:password]@]host[:port]>

Use Intel AMT technology to control the target machine. WS management
is used to powercycle it and Serial-Over-Lan (SOL) for input/output.
The hostname or (IP address) is given by the I<host> parameter. If
I<password> is not specified, environment variable AMT_PASSWORD is
used. The I<port> specifies a TCP port for SOL. If not specified, the
default is 16992. Default I<user> is admin.

=item --iprelay=I<addr[:port]>

Use TCP/IP relay and serial port to access the target's serial port
and powercycle it. The IP address of the relay is given by I<addr>
parameter. If I<port> is not specified, it default to 23.

Note: This option is supposed to work with HWG-ER02a IP relays.

=item -s, --serial[=device]

Target's serial line is connected to host's serial line (device). The
default value for device is F</dev/ttyUSB0>.

The value of this option is exported in NB_NOVABOOT environment
variable to all subprocesses run by C<novaboot>.

=item --stty=I<settings>

Specifies settings passed to C<stty> invoked on the serial line
specified with B<--serial> option. If this option is not given,
C<stty> is called with C<raw -crtscts -onlcr 115200> settings.

=item --remote-cmd=I<cmd>

Command that mediates connection to the target's serial line. For
example C<ssh server 'cu -l /dev/ttyS0'>.

=item --remote-expect=I<string>

Wait for reception of I<string> after establishing the the remote
connection before continuing.


=back

=head2 File deployment phase

In some setups, it is necessary to copy the files needed for booting
to a particular location, e.g. to a TFTP boot server or to the
F</boot> partition.

=over 8

=item -d, --dhcp-tftp

Turns your workstation into a DHCP and TFTP server so that the OS can
be booted via PXE BIOS (or similar mechanism) on the test machine
directly connected by a plain Ethernet cable to your workstation.

The DHCP and TFTP servers requires root privileges and C<novaboot>
uses C<sudo> command to obtain those. You can put the following to
I</etc/sudoers> to allow running the necessary commands without asking
for password.

 Cmnd_Alias NOVABOOT = /bin/ip a add 10.23.23.1/24 dev eth0, /bin/ip l set dev eth0 up, /usr/sbin/dhcpd -d -cf dhcpd.conf -lf dhcpd.leases -pf dhcpd.pid, /usr/sbin/in.tftpd --listen --secure -v -v -v --pidfile tftpd.pid *, /usr/bin/touch dhcpd.leases, /usr/bin/pkill --pidfile=dhcpd.pid, /usr/bin/pkill --pidfile=tftpd.pid
 your_login ALL=NOPASSWD: NOVABOOT

=item --tftp

Starts a TFTP server on your workstation. This is similar to
B<--dhcp-tftp> except that DHCP server is not started.

The TFTP server require root privileges and C<novaboot> uses C<sudo>
command to obtain those. You can put the following to I</etc/sudoers>
to allow running the necessary commands without asking for password.

 Cmnd_Alias NOVABOOT =  /usr/sbin/in.tftpd --listen --secure -v -v -v --pidfile tftpd.pid *, /usr/bin/pkill --pidfile=tftpd.pid
 your_login ALL=NOPASSWD: NOVABOOT

=item --tftp-port=I<port>

Port to run the TFTP server on. Implies B<--tftp>.

=item --iso[=filename]

Generates the ISO image that boots NOVA system via GRUB. If no filename
is given, the image is stored under I<NAME>.iso, where I<NAME> is the name
of the novaboot script (see also B<--name>).

=item --server[=[[user@]server:]path]

Copy all files needed for booting to another location. The files will
be copied (by B<rsync> tool) to the directory I<path>. If the I<path>
contains string $NAME, it will be replaced with the name of the
novaboot script (see also B<--name>).

=item --rsync-flags=I<flags>

Specifies which I<flags> are appended to F<rsync> command line when
copying files as a result of I<--server> option.

=item --concat

If B<--server> is used and its value ends with $NAME, then after
copying the files, a new bootloader configuration file (e.g. menu.lst)
is created at I<path-wo-name>, i.e. the path specified by B<--server>
with $NAME part removed. The content of the file is created by
concatenating all files of the same name from all subdirectories of
I<path-wo-name> found on the "server".

=item --ider

Use Intel AMT technology for IDE redirection. This allows the target
machine to boot from novaboot created ISO image. Implies B<--iso>.

The experimental C<amtider> utility needed by this option can be
obtained from https://github.com/wentasah/amtterm.

=back

=head2 Target power-on and reset phase

At this point, the target is reset (or switched on/off). There is
several ways how this can be accomplished. Resetting a physical target
can currently be accomplished by the following options: B<--amt>,
B<--iprelay>, B<--reset-cmd>.

=over 8

=item --on, --off

Switch on/off the target machine and exit. The script (if any) is
completely ignored. Currently it works only with B<--iprelay> or
B<--amt>.

=item -Q, --qemu[=I<qemu-binary>]

Boot the configuration in qemu. Optionally, the name of qemu binary
can be specified as a parameter.

=item --qemu-append=I<flags>

Append I<flags> to the default qemu flags (QEMU_FLAGS variable or
C<-cpu coreduo -smp 2>).

=item -q, --qemu-flags=I<flags>

Replace the default qemu flags (QEMU_FLAGS variable or C<-cpu coreduo
-smp 2>) with I<flags> specified here.

=item --reset-cmd=I<cmd>

Command that resets the target.

=item --no-reset, --reset

Disable/enable reseting of the target.

=back

=head2 Interaction with the bootloader on the target

=over 8

=item --uboot[=I<prompt>]

Interact with U-Boot bootloader to boot the thing described in the
novaboot script. I<prompt> specifies the U-Boot's prompt (default is
"=> ", other common prompts are "U-Boot> " or "U-Boot# ").
Implementation of this option is currently tied to a particular board
that we use. It may be subject to changes in the future!

=item --uboot-init

Command(s) to send the U-Boot bootloader before loading the images and
booting them. This option can be given multiple times. After sending
commands from each option novaboot waits for U-Boot I<prompt>.

If the command contains string I<$NB_MYIP> then this string is
replaced by IPv4 address of eth0 interface. Similarly I<$NB_PREFIX> is
replaced with prefix given by B<--prefix>.

See also C<uboot> keyword in L</"NOVABOOT SCRIPT SYNTAX">).

=item --uboot-addr I<name>=I<address>

Load address of U-Boot's C<tftpboot> command for loading I<name>,
where name is one of I<kernel>, I<ramdisk> or I<fdt> (flattened device
tree).

=back

=head2 Target interaction phase

In this phase, target's serial output is redirected to stdout and if
stdin is a TTY, it is redirected to the target's serial input allowing
interactive work with the target.

=over 8

=item --exiton=I<string>

When I<string> is sent by the target, novaboot exits. This option can
be specified multiple times, in which case novaboot exits whenever
either of the specified strings is sent.

If I<string> is C<-re>, then the next B<--exiton>'s I<string> is
treated as regular expression. For example:

    --exiton -re --exiton 'error:.*failed'

=item --exiton-re=I<regex>

The same as --exiton -re --exiton I<regex>.

=item --exiton-timeout=I<seconds>

By default B<--exiton> waits for the string match forever. When this
option is specified, "exiton" timeouts after the specifies number of
seconds and novaboot returns non-zero exit code.

=item -i, --interactive

Setup things for interactive use of target. Your terminal will be
switched to raw mode. In raw mode, your system does not process input
in any way (no echoing of entered characters, no interpretation
special characters). This, among others, means that Ctrl-C is passed
to the target and does no longer interrupt novaboot. Use "~~."
sequence to exit novaboot.

=item --expect=I<string>

When I<string> is received from the target, send the string specified
with the subsequent B<--send*> option to the target.

=item --expect-re=I<regex>

When target's output matches regular expression I<regex>, send the
string specified with the subsequent B<--send*> option to the target.

=item --expect-raw=I<perl-code>

Provides direct control over Perl's Expect module.

=item --send=I<string>

Send I<string> to the target after the previously specified
B<--expect*> was matched in the target's output. The I<string> may
contain escape sequences such as "\n".

Note that I<string> is actually interpreted by Perl, so it can contain
much more that escape sequences. This behavior may change in the
future.

Example: C<--expect='login: ' --send='root\n'>

=item --sendcont=I<string>

Similar to B<--send> but continue expecting more input.

Example: C<--expect='Continue?' --sendcont='yes\n'>

=back

=head1 NOVABOOT SCRIPT SYNTAX

The syntax tries to mimic POSIX shell syntax. The syntax is defined
with the following rules.

Lines starting with "#" and empty lines are ignored.

Lines that end with "\" are concatenated with the following line after
removal of the final "\" and leading whitespace of the following line.

Lines of the form I<VARIABLE=...> (i.e. matching '^[A-Z_]+=' regular
expression) assign values to internal variables. See L</VARIABLES>
section.

Lines starting with C<load> keyword represent modules to boot. The
word after C<load> is a file name (relative to the build directory
(see B<--build-dir>) of the module to load and the remaining words are
passed to it as the command line parameters.

When the C<load> line ends with "<<WORD" then the subsequent lines
until the line containing solely WORD are copied literally to the file
named on that line. This is similar to shell's heredoc feature.

When the C<load> line ends with "< CMD" then command CMD is executed
with F</bin/sh> and its standard output is stored in the file named on
that line. The SRCDIR variable in CMD's environment is set to the
absolute path of the directory containing the interpreted novaboot
script.

Lines starting with C<run> keyword contain shell commands that are run
during file generation phase. This is the same as the "< CMD" syntax
for C<load> keyboard except that the command's output is not
redirected to a file. The ordering of commands is the same as they
appear in the novaboot script.

Lines starting with C<uboot> represent U-Boot commands that are sent
to the target if B<--uboot> option is given. Having a U-Boot line in
the novaboot script is the same as passing an equivalent
B<--uboot-init> option to novaboot. The C<uboot> keyword can be
suffixed with timeout specification. The syntax is C<uboot:Ns>, where
C<N> is the whole number of seconds. If the U-Boot command prompt does
not appear before the timeout, novaboot fails. The default timeout is
10 seconds.

Example (Linux):

  #!/usr/bin/env novaboot
  load bzImage console=ttyS0,115200
  run  make -C buildroot
  load rootfs.cpio < gen_cpio buildroot/images/rootfs.cpio "myapp->/etc/init.d/S99myapp"

Example (NOVA User Land - NUL):

  #!/usr/bin/env novaboot
  WVDESC=Example program
  load bin/apps/sigma0.nul S0_DEFAULT script_start:1,1 \
                           verbose hostkeyb:0,0x60,1,12,2
  load bin/apps/hello.nul
  load hello.nulconfig <<EOF
  sigma0::mem:16 name::/s0/log name::/s0/timer name::/s0/fs/rom ||
  rom://bin/apps/hello.nul
  EOF

This example will load three modules: F<sigma0.nul>, F<hello.nul> and
F<hello.nulconfig>. sigma0 receives some command line parameters and
F<hello.nulconfig> file is generated on the fly from the lines between
C<<<EOF> and C<EOF>.

=head2 VARIABLES

The following variables are interpreted in the novaboot script:

=over 8

=item BUILDDIR

Novaboot chdir()s to this directory before file generation phase. The
directory name specified here is relative to the build directory
specified by other means (see L</--build-dir>).

=item EXITON

Assigning this variable has the same effect as specifying L</--exiton>
option.

=item HYPERVISOR_PARAMS

Parameters passed to hypervisor. The default value is "serial", unless
overridden in configuration file.

=item KERNEL

The kernel to use instead of the hypervisor specified in the
configuration file with the C<$hypervisor> variable. The value should
contain the name of the kernel image as well as its command line
parameters. If this variable is defined and non-empty, the variable
HYPERVISOR_PARAMS is not used.

=item NO_BOOT

If this variable is 1, the system is not booted. This is currently
only implemented for U-Boot bootloader where it is useful for
interacting with the bootloader without booting the system - e.g. for
flashing.

=item QEMU

Use a specific qemu binary (can be overridden with B<-Q>) and flags
when booting this script under qemu. If QEMU_FLAGS variable is also
specified flags specified in QEMU variable are replaced by those in
QEMU_FLAGS.

=item QEMU_FLAGS

Use specific qemu flags (can be overridden with B<-q>).

=item WVDESC

Description of the WvTest-compliant program.

=item WVTEST_TIMEOUT

The timeout in seconds for WvTest harness. If no complete line appears
in the test output within the time specified here, the test fails. It
is necessary to specify this for long running tests that produce no
intermediate output.

=back

=head1 CONFIGURATION FILE

Novaboot can read its configuration from one or more files. By
default, novaboot looks for files in F</etc/novaboot.d> and files
named F<.novaboot> as described in L</Configuration reading phase>.
Alternatively, configuration file location can be specified with the
B<-c> switch or with the NOVABOOT_CONFIG environment variable. The
configuration file has Perl syntax (i.e. it is better to put C<1;> as
a last line) and should set values of certain Perl variables. The
current configuration can be dumped with the B<--dump-config> switch.
Some configuration variables can be overridden by environment
variables (see below) or by command line switches.

Supported configuration variables include:

=over 8

=item $builddir

Build directory location relative to the location of the configuration
file.

=item $default_target

Default target (see below) to use when no target is explicitly
specified on command line with the B<--target> option.

=item %targets

Hash of target definitions to be used with the B<--target> option. The
key is the identifier of the target, the value is the string with
command line options. For instance, if the configuration file contains:

 $targets{'mybox'} = '--server=boot:/tftproot --serial=/dev/ttyUSB0 --grub',

then the following two commands are equivalent:

 ./myos --server=boot:/tftproot --serial=/dev/ttyUSB0 --grub
 ./myos -t mybox

=back

=head1 ENVIRONMENT VARIABLES

Some options can be specified not only via config file or command line
but also through environment variables. Environment variables override
the values from configuration file and command line parameters
override the environment variables.

=over 8

=item NOVABOOT_CONFIG

Name of the novaboot configuration file to use instead of the default
one(s).

=item NOVABOOT_CONFIG_DIR

Name of the novaboot configuration directory. When not specified
F</etc/novaboot.d> is used.

=item NOVABOOT_BENDER

Defining this variable has the same meaning as B<--bender> option.

=back

=head1 AUTHORS

Michal Sojka <sojka@os.inf.tu-dresden.de>

=cut

# LocalWords:  novaboot Novaboot NOVABOOT TFTP PXE DHCP filename stty
# LocalWords:  chainloader stdout Qemu qemu preprocessing ISOLINUX bootable
# LocalWords:  config subprocesses sudo sudoers tftp dhcp IDE stdin
# LocalWords:  subdirectories TTY whitespace heredoc POSIX WvTest
